/*

再谈生命周期.

单一所有者, 不纯粹. 某些情况下出现了引用.
引用.  原始值 和 引用的关系.  就像 ptr 和 obj的关系.

rust 要保证, 引用不能比对象活的还久.  否则就是悬垂指针.

rust 于是,rust 有了一些规定.

1. 如果参数没有, 或者只有1个引用. 那么编译器自己去推断.

2. 如果参数有多个引用,  而且返回值, 也是引用.
   这个时候,编译器就需要程序员, 给出具体辅助信息了.
   这些辅助信息, 用于表示, 返回值 和 参数 的 存活时间对比.

3. 这样的辅助信息, 被定义为生命周期.

考虑下面这个例子:

fn max_str(a :&str, b :&str)->&str {
    "abc"
}

按道理说, 上面的程序非常简单, 和参数都没关系. 但是rust 编译器.
一看声明, 多个引用, 返回引用.  好了 他知道这类函数他可能处理不了.
必须要辅助信息. 所以编译同不过.

让其编译通过的最小改动就是下面这样.
fn max_str<'a>(a :&str, b :&str)->&'a str {
    "abc"
}

4. 生命周期标注  'a 到底是什么, rust这样任务, 如果参数也标注了这个 'a.
   那么'a 就是所有参数中, 生命周期的交集.(最短的那个).
   返回值也标注了 'a. 返回值就要至少和参数最小的那个,活的一样久.

   想想经典的 :   max_str()

*/


fn max_str<'a>(a :&str, b :&str)->&'a str {
    "abc" //可以理解为静态生命周期.
}

fn max2_str(a :&str)->&str {
    "abcd"
}

fn max3_str<'a>(a :& 'a str, b :&str)->&'a str{
    a
}

fn max4_str<'a, 'b>(a :& 'a str, b :& 'b str)->&'b str{
    // a  如果返回a, 这里编译不过. 没法确定 返回值 和 a的关系.
    b //这样可以.
}


#[test]
fn lc_fn() {
    let x = max_str("bc","de");
    println!("rt = {}", x);

    let x = max2_str("bcde");
    println!("rt = {}", x);
}